(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{103:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return s})),n.d(t,"default",(function(){return l}));var a=n(3),r=n(7),o=(n(0),n(121)),i={id:"routes",title:"Routes",sidebar_label:"Routes",slug:"routes"},c={unversionedId:"routes",id:"routes",isDocsHomePage:!1,title:"Routes",description:"A route (IRoute) represents the code you want to run and the conditions under which you want it to be run. Any method or function you want to execute must be asynchronous (returns a Task) and take a single parameter of type IHttpContext.",source:"@site/docs\\gv-routes.md",slug:"/routes",permalink:"/grapevine/docs/routes",editUrl:"https://github.com/scottoffen/grapevine-docs/edit/master/docs/gv-routes.md",version:"current",sidebar_label:"Routes",sidebar:"someSidebar",previous:{title:"Overview",permalink:"/grapevine/docs/"},next:{title:"Route Scanner",permalink:"/grapevine/docs/route-scanner"}},s=[{value:"Creating A Route From A Lambda",id:"creating-a-route-from-a-lambda",children:[]},{value:"Creating A Route From A Function",id:"creating-a-route-from-a-function",children:[]},{value:"Creating A Route From A Method",id:"creating-a-route-from-a-method",children:[{value:"Instance Method",id:"instance-method",children:[]},{value:"Static Method",id:"static-method",children:[]}]},{value:"Specifying the Path Info",id:"specifying-the-path-info",children:[{value:"Hard Coded String",id:"hard-coded-string",children:[]},{value:"Parameterized String",id:"parameterized-string",children:[]},{value:"Regular Expressions",id:"regular-expressions",children:[]},{value:"Route Specific Path Parameters",id:"route-specific-path-parameters",children:[]}]},{value:"Specifying the Http Verb",id:"specifying-the-http-verb",children:[]},{value:"Limit Route Matching Using Headers",id:"limit-route-matching-using-headers",children:[]},{value:"Enable And Disable Routes",id:"enable-and-disable-routes",children:[]},{value:"Route Name and Description",id:"route-name-and-description",children:[]}],u={toc:s};function l(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"A route (",Object(o.b)("inlineCode",{parentName:"p"},"IRoute"),") represents the code you want to run and the conditions under which you want it to be run. Any method or function you want to execute must be asynchronous (returns a ",Object(o.b)("inlineCode",{parentName:"p"},"Task"),") and take a single parameter of type ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/grapevine/docs/http-context"}),Object(o.b)("inlineCode",{parentName:"a"},"IHttpContext")),"."),Object(o.b)("p",null,"A route requires only three things: The code to execute, and the HTTP verb (",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/grapevine/docs/http-methods"}),Object(o.b)("inlineCode",{parentName:"a"},"HttpMethod")),") and path info it should execute on. If you don't specify a verb, the route will execute for any verbs with the specified path info. If you don't specify the path info, the route will execute for any path info for the specified verb. If you don't specify either the verb or the path info, this will create a sort of catch-all route, which may or may not be desireable."),Object(o.b)("h2",{id:"creating-a-route-from-a-lambda"},"Creating A Route From A Lambda"),Object(o.b)("p",null,"You can create a route from a lambda expression:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var route = new Route(async (ctx) =>\n{\n    await ctx.Response.SendResponseAsync("route from lambda expression");\n}, "Get", "/lambda"));\n')),Object(o.b)("h2",{id:"creating-a-route-from-a-function"},"Creating A Route From A Function"),Object(o.b)("p",null,"You can generate a route using a ",Object(o.b)("inlineCode",{parentName:"p"},"Func<IHttpContext, Task>"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'Func<IHttpContext, Task> callback = async (ctx) =>\n{\n    await ctx.Response.SendResponseAsync("route from func");\n};\n\nvar route = new Route(callback, "Get", "/function");\n')),Object(o.b)("h2",{id:"creating-a-route-from-a-method"},"Creating A Route From A Method"),Object(o.b)("p",null,"Routes can be generated from both static and instance methods. Instance methods must be on a class that can be instantiated."),Object(o.b)("h3",{id:"instance-method"},"Instance Method"),Object(o.b)("p",null,"When using an instance method, we will generate a route with a generic parameter."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp",metastring:"{10}","{10}":!0}),'public class TestResource\n{\n    public async Task TestRoute(IHttpContext context)\n    {\n        await context.Response.SendResponseAsync("route from method");\n    }\n}\n\nvar methodInfo = typeof(TestResource).GetMethod("TestRoute");\nvar route = new Route<TestResource>(methodInfo, "Get", "/instance-method");\n')),Object(o.b)("p",null,"When registering a route that is generated from an instance method like this with the router, you will also need to add the class to the service collection."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp",metastring:"{2}","{2}":!0}),"server.Router.Register(route);\nserver.Router.ServiceCollection.AddScoped<TestResource>();\n")),Object(o.b)("h3",{id:"static-method"},"Static Method"),Object(o.b)("p",null,"When generating a route from a static method, you treat it like you would a ",Object(o.b)("inlineCode",{parentName:"p"},"Func<IHttpContext, Task>"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'public static class StaticTestResource\n{\n    public static async Task StaticTestRoute(IHttpContext context)\n    {\n        await context.Response.SendResponseAsync("route from static method");\n    }\n}\n\nvar route = new Route(StaticTestResource.StaticTestRoute, "Get", "/static-method");\n')),Object(o.b)("h2",{id:"specifying-the-path-info"},"Specifying the Path Info"),Object(o.b)("p",null,"The path info is extra path data that follows the prefix the request comes in on. There are a few different ways to specify the path info the routes shoudl respond to when creating a route."),Object(o.b)("h3",{id:"hard-coded-string"},"Hard Coded String"),Object(o.b)("p",null,"This is the most straight forward. In the example below, this route will execute when the path info is ",Object(o.b)("inlineCode",{parentName:"p"},"/some/path"),"."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var route = new Route(callback, "Any", "/some/path");\n')),Object(o.b)("h3",{id:"parameterized-string"},"Parameterized String"),Object(o.b)("p",null,"You can put parameters in the path info by enclosing them in curly braces."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var route = new Route(callback, "Any", "/users/{id}");\n')),Object(o.b)("p",null,"In this example, the route would respond to calls made to all of ",Object(o.b)("inlineCode",{parentName:"p"},"/users/1234"),", ",Object(o.b)("inlineCode",{parentName:"p"},"/users/rudy")," and ",Object(o.b)("inlineCode",{parentName:"p"},"/users/1a2b3c"),", but not to ",Object(o.b)("inlineCode",{parentName:"p"},"/users")," or ",Object(o.b)("inlineCode",{parentName:"p"},"/users/1234/rudy"),"."),Object(o.b)("p",null,"The id parameter specified in the route can be obtained from the request by key via the ",Object(o.b)("inlineCode",{parentName:"p"},"IHttpContext.Request.PathParameters")," property."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var id = context.Request.PathParameters["id"];\n')),Object(o.b)("p",null,"You can use multiple parameters in your string, and they do not need to be consecutive. The parameter names do need to be unique, or a runtime exception is thrown."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var route = new Route(callback, "Any", "/{resource}/list/{id}/gumbo");\n')),Object(o.b)("div",{className:"admonition admonition-tip alert alert--success"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"})))),"tip")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"Earlier versions of Grapevine used square brackets to denote parameters in the path info. This has been changed to curly braces in Grapevine 5 to match ASP.NET patterns."))),Object(o.b)("h3",{id:"regular-expressions"},"Regular Expressions"),Object(o.b)("p",null,"You can express the path info pattern as a regular expression string or as a ",Object(o.b)("inlineCode",{parentName:"p"},"Regex")," instance. ",Object(o.b)("strong",{parentName:"p"},"If the path info string begins with a caret (",Object(o.b)("inlineCode",{parentName:"strong"},"^"),"), the string will be treated as a regular expression.")," Regular expressions can be useful when the value needs to match a specific pattern (e.g. the user id is between 3 and 5 digits long)."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var expr = @"^/users/(/d{3,5})";\nvar route1 = new Route(callback, "Any", expr);\nvar route2 = new Route(callback, "Any", new Regex(expr));\n')),Object(o.b)("p",null,"Capture groups specified in the regular expression can be accessed in the same way as named parameters in parameterized strings, but the key will instead be the numbered capture group preceeded by a lower-case ",Object(o.b)("inlineCode",{parentName:"p"},"p"),". In the exampel above, the id would be referenced as ",Object(o.b)("inlineCode",{parentName:"p"},'IHttpContext.Request.PathParameters["p0"]')),Object(o.b)("h3",{id:"route-specific-path-parameters"},"Route Specific Path Parameters"),Object(o.b)("p",null,"If multiple routes are executed, but have different named (or unnamed) path parameters, they will be named and accessed based on how the route was defined. The following example uses ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"/grapevine/docs/locals"}),"locals")," to demonstrate. Notice how in each callback the route parameters are referenced using different names, but the same values are assigned to them."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'Func<IHttpContext, Task> callbackA = async (ctx) =>\n{\n    if (!context.Contains("PathParameters")) context.Set("PathParameters", new StringBuilder());\n    var sb = context.GetAs<StringBuilder>("PathParameters");\n\n    sb.Append($"A: Count: {context.Request.PathParameters.Count}{Environment.NewLine}");\n    sb.Append($"\\tkey: {context.Request.PathParameters["key"]}{Environment.NewLine}");\n    sb.Append($"\\tvalue: {context.Request.PathParameters["value"]}{Environment.NewLine}");\n\n    await Task.CompletedTask;\n};\n\nFunc<IHttpContext, Task> callbackB = async (ctx) =>\n{\n    if (!context.Contains("PathParameters")) context.Set("PathParameters", new StringBuilder());\n    var sb = context.GetAs<StringBuilder>("PathParameters");\n\n    sb.Append($"B: Count: {context.Request.PathParameters.Count}{Environment.NewLine}");\n    sb.Append($"\\tp0: {context.Request.PathParameters["p0"]}{Environment.NewLine}");\n    sb.Append($"\\tp1: {context.Request.PathParameters["p1"]}{Environment.NewLine}");\n\n    await Task.CompletedTask;\n};\n\nFunc<IHttpContext, Task> callbackC = async (ctx) =>\n{\n    if (!context.Contains("PathParameters")) context.Set("PathParameters", new StringBuilder());\n    var sb = context.GetAs<StringBuilder>("PathParameters");\n\n    sb.Append($"C: Count: {context.Request.PathParameters.Count}{Environment.NewLine}");\n    sb.Append($"\\tthing1: {context.Request.PathParameters["thing1"]}{Environment.NewLine}");\n    sb.Append($"\\tthing2: {context.Request.PathParameters["thing2"]}{Environment.NewLine}");\n\n    await context.Response.SendResponseAsync(sb.ToString());\n};\n\nvar routeA = new Route(callbackA, "Get", "/api/test/{key}/{value}");\nvar routeB = new Route(callbackB, "Get", new Regex(@"^/api/test/([a-zA-Z]+)/(\\d{1,})"));\nvar routeC = new Route(callbackC, "Get", "/api/test/{thing1}/{thing2}");\n')),Object(o.b)("p",null,"When those three routes are registered in order and you go to the url ",Object(o.b)("inlineCode",{parentName:"p"},"http://localhost:1234/api/test/abc/123"),", the output will look like this:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{}),"A: Count: 2\n    key: abc\n    value: 123\nB: Count: 2\n    p0: abc\n    p1: 123\nC: Count: 2\n    thing1: abc\n    thing2: 123\n")),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"The path info when passed as a string is ultimately translated into a regular expression.")),Object(o.b)("h2",{id:"specifying-the-http-verb"},"Specifying the Http Verb"),Object(o.b)("p",null,"The helper class ",Object(o.b)("inlineCode",{parentName:"p"},"HttpMethod")," can be used to specify the verb for matching routes. It contains a number of static properties the ensure consistency."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var route = new Route(callback, HttpMethod.Get, "/some/path");\n')),Object(o.b)("p",null,"In order to avoid ambiguity between ",Object(o.b)("inlineCode",{parentName:"p"},"Grapevine.HttpMethod")," and ",Object(o.b)("inlineCode",{parentName:"p"},"System.Net.Http.HttpMethod"),", you can also use a string to specify the method."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var route = new Route(callback, "Get", "/some/path");\n')),Object(o.b)("h2",{id:"limit-route-matching-using-headers"},"Limit Route Matching Using Headers"),Object(o.b)("p",null,"You can also further limit whether a route is matched to a request based on the value of any header."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var route = new Route(callback, "Get", "/some/path")\n    .WithHeader("Host", new Regex(@"^localhost:1234$"));\n')),Object(o.b)("p",null,"This method is chainable, so you can add as many header conditions as needed."),Object(o.b)("h2",{id:"enable-and-disable-routes"},"Enable And Disable Routes"),Object(o.b)("p",null,"Routes can be enabled and disabled. Only enabled routes will be matched by the router, and only enabled routes will be invoked."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var route = new Route(callback, "Get", "/some/path", false)\n    .Enable()   // extension method\n    .Disable(); // extension method\n\n// Direct property access\nroute.Enabled = true\n')),Object(o.b)("h2",{id:"route-name-and-description"},"Route Name and Description"),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"Name")," and ",Object(o.b)("inlineCode",{parentName:"p"},"Description")," properties are primarily used in output when debugging and logging. You can change them at any time. You can also use the ",Object(o.b)("inlineCode",{parentName:"p"},"Name")," property to retrieve a route from the routers routing table. While uniquness is not required, in this last case, it will be helpful if your route names are unique."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),'var route = server.Router.RoutingTable\n    .Where(r => r.Name == "Some Unique Name")\n    .FirstOrDefault();\n')))}l.isMDXComponent=!0},121:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=r.a.createContext({}),l=function(e){var t=r.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},p=function(e){var t=l(e.components);return r.a.createElement(u.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},d=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(n),d=a,h=p["".concat(i,".").concat(d)]||p[d]||b[d]||o;return n?r.a.createElement(h,c(c({ref:t},u),{},{components:n})):r.a.createElement(h,c({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var u=2;u<o;u++)i[u]=n[u];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);